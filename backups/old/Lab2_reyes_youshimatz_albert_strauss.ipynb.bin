{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Generación y Visualización de Datos Multivariados\n",
    "\n",
    "Esta notebook genera datos multivariados utilizando distribuciones normales y permite visualizarlos en 2D o 3D\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Librerías"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 83,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import plotly.express as px\n",
    "import plotly.graph_objects as go\n",
    "import pandas as pd\n",
    "from scipy.spatial.distance import cdist\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Clase MultivariateNormalDataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 84,
   "metadata": {},
   "outputs": [],
   "source": [
    "class MultivariateNormalDataset:\n",
    "    def __init__(self, n_num_puntos, medias, covs):\n",
    "        \"\"\"\n",
    "        Inicializa la clase con el número de puntos, las medias y las matrices de covarianza.\n",
    "\n",
    "        :param n_num_puntos: Lista con el número de elementos por cada clase.\n",
    "        :param medias: Lista de vectores de media para cada clase.\n",
    "        :param covs: Lista de matrices de covarianza para cada clase.\n",
    "        \"\"\"\n",
    "        self.n_num_puntos = n_num_puntos\n",
    "        self.medias = medias\n",
    "        self.covs = covs\n",
    "        self.generador()\n",
    "\n",
    "    def generador(self):\n",
    "        \"\"\"\n",
    "        Genera y retorna el conjunto de datos multivariado basado los inputs proporcionados.\n",
    "        \"\"\"\n",
    "        all_data = []\n",
    "        labels = []\n",
    "\n",
    "        for i, (n_samples, mean, cov) in enumerate(zip(self.n_num_puntos, self.medias, self.covs)):\n",
    "            class_data = np.random.multivariate_normal(mean, cov, n_samples)\n",
    "            all_data.append(class_data)\n",
    "            labels.append(np.full(n_samples, i))\n",
    "\n",
    "        combined_data = np.vstack(all_data)\n",
    "        combined_labels = np.concatenate(labels)\n",
    "\n",
    "        self.data_with_labels = np.column_stack((combined_data, combined_labels))\n",
    "\n",
    "    def graficar(self, modo='2D', dims=None):\n",
    "        \"\"\"\n",
    "        Genera una gráfica interactiva de los datos ya sea en 2D o 3D a elección.\n",
    "        \n",
    "        :param modo: Tipo de gráfica ('2D' o '3D').\n",
    "        :param dims: Lista con las dimensiones a graficar (por defecto, las primeras 2 o 3).\n",
    "        \"\"\"\n",
    "        num_dimensions = self.data_with_labels.shape[1] - 1\n",
    "\n",
    "        df = pd.DataFrame(self.data_with_labels, columns=[f'X{i+1}' for i in range(num_dimensions)] + ['Clase'])\n",
    "\n",
    "        if dims is None:\n",
    "            dims = list(range(1, min(num_dimensions, 3) + 1))\n",
    "\n",
    "        if modo == '3D' and len(dims) == 3:\n",
    "            fig = px.scatter_3d(df, x=f'X{dims[0]}', y=f'X{dims[1]}', z=f'X{dims[2]}', color='Clase',\n",
    "                                labels={f'X{dims[0]}': f'Dim {dims[0]}', f'X{dims[1]}': f'Dim {dims[1]}', f'X{dims[2]}': f'Dim {dims[2]}'},\n",
    "                                title='Gráfica de Dispersión 3D de Datos Multivariados')\n",
    "            fig.show()\n",
    "        elif modo == '2D' and len(dims) >= 2:\n",
    "            fig = px.scatter(df, x=f'X{dims[0]}', y=f'X{dims[1]}', color='Clase',\n",
    "                             labels={f'X{dims[0]}': f'Dim {dims[0]}', f'X{dims[1]}': f'Dim {dims[1]}'},\n",
    "                             title='Gráfica de Dispersión 2D de Datos Multivariados')\n",
    "            fig.show()\n",
    "        else:\n",
    "            print(f\"Para un gráfico 3D, selecciona exactamente 3 dimensiones. Para un gráfico 2D, selecciona al menos 2 dimensiones.\")\n",
    "\n",
    "    def get_num_puntos(self):\n",
    "        \"\"\" Getter para obtener el numero total de puntos en el dataset.\"\"\"\n",
    "        return sum(self.n_num_puntos)  # Suma los puntos de todas las clases y retorna el total\n",
    "\n",
    "    def get_dimensiones(self):\n",
    "        \"\"\" Getter que devuelve el número de dimensiones.\"\"\"\n",
    "        return len(self.medias[0])\n",
    "    \n",
    "    def distancia_punto_punto(self, punto, metrica='euclidean'):\n",
    "        \"\"\"\n",
    "        Calcula la distancia entre un punto dado y todos los puntos en el dataset.\n",
    "\n",
    "        :param punto: El punto del que se calcula la distancia.\n",
    "        :param metrica: La métrica de distancia a utilizar.\n",
    "        :return: Un array con las distancias entre el punto dado y todos los puntos en el dataset.\n",
    "        \"\"\"\n",
    "        puntos = self.data_with_labels[:, :-1]  # Excluye la última columna (etiquetas).\n",
    "        \n",
    "        # Calcula las distancias usando cdist.\n",
    "        distancias = cdist([punto], puntos, metric=metrica)\n",
    "        \n",
    "        return distancias\n",
    "    \n",
    "    def distancia_punto_subconjunto(self, punto, indices_subconjunto, metrica='euclidean'):\n",
    "        \"\"\"\n",
    "        Calcula la distancia entre un punto dado y un subconjunto de puntos en el dataset.\n",
    "\n",
    "        :param punto: El punto del que se calcula la distancia.\n",
    "        :param indices_subconjunto: Índices de los puntos que forman el subconjunto.\n",
    "        :param metrica: La métrica de distancia a utilizar.\n",
    "        :return: Un array con las distancias entre el punto dado y los puntos en el subconjunto.\n",
    "        \"\"\"\n",
    "        subconjunto = self.data_with_labels[indices_subconjunto, :-1]  # Excluye la última columna (etiquetas).\n",
    "        \n",
    "        # Calcula las distancias usando cdist.\n",
    "        distancias = cdist([punto], subconjunto, metric=metrica)\n",
    "        \n",
    "        # Calcular medidas de proximidad\n",
    "        max_proximity =np.max(distancias) \n",
    "        min_proximity = np.min(distancias)\n",
    "\n",
    "        \n",
    "        dic =  {\n",
    "            'max_proximity': max_proximity,\n",
    "            'min_proximity': min_proximity\n",
    "        }\n",
    "        return dic\n",
    "    \n",
    "    \n",
    "    \n",
    "    def distancia_subconjunto_subconjunto(self, indices_subconjunto1, indices_subconjunto2, metrica='euclidean'):\n",
    "        \"\"\"\n",
    "        Calcula las medidas de proximidad entre dos subconjuntos de puntos en el dataset.\n",
    "\n",
    "        :param indices_subconjunto1: Índices de los puntos del primer subconjunto.\n",
    "        :param indices_subconjunto2: Índices de los puntos del segundo subconjunto.\n",
    "        :param metrica: La métrica de distancia a utilizar.\n",
    "        :return: Un diccionario con las medidas de proximidad.\n",
    "        \"\"\"\n",
    "        subconjunto1 = self.data_with_labels[indices_subconjunto1, :-1]  # Excluye la última columna (etiquetas).\n",
    "        subconjunto2 = self.data_with_labels[indices_subconjunto2, :-1]  # Excluye la última columna (etiquetas).\n",
    "        \n",
    "        # Calcula las distancias usando cdist.\n",
    "        distancias = cdist(subconjunto1, subconjunto2, metric=metrica)\n",
    "        \n",
    "        # Calcular medidas de proximidad\n",
    "        max_proximity =np.max(distancias) \n",
    "        min_proximity = np.min(distancias)\n",
    "\n",
    "        \n",
    "        dic =  {\n",
    "            'max_proximity': max_proximity,\n",
    "            'min_proximity': min_proximity\n",
    "        }\n",
    "\n",
    "        return dic    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Ejemplo de uso"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 85,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Crear un objeto de la clase\n",
    "dataset = MultivariateNormalDataset(\n",
    "    n_num_puntos=[10, 15], \n",
    "    medias=[[1, 2], [3, 4]], \n",
    "    covs=[[[1, 0.5], [0.5, 1]], [[1, -0.5], [-0.5, 1]]]\n",
    ")\n",
    "\n",
    "# Definir un punto\n",
    "punto = [2, 2]\n",
    "\n",
    "# Índices de subconjuntos\n",
    "indices_subconjunto1 = [0, 1, 2, 3, 4]\n",
    "indices_subconjunto2 = [5, 6, 7, 8, 9]\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 86,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Distancias del punto a todos los puntos en el dataset:\n",
      "[[1.27670744 1.54645362 1.56722356 1.04980789 2.32109281 1.91423021\n",
      "  2.11285488 1.0559589  1.69503326 1.48581548 2.6332911  2.49554501\n",
      "  2.52343242 3.63178998 2.15090499 3.06594151 2.6138382  1.24633629\n",
      "  2.09482638 4.13023323 2.06019219 2.04404603 3.46616933 2.01182492\n",
      "  2.57708806]]\n",
      "\n",
      "Distancias del punto al subconjunto:\n",
      "{'max_proximity': 2.321092806188118, 'min_proximity': 1.0498078869835266}\n",
      "\n",
      "Medidas de proximidad entre subconjuntos:\n",
      "{'max_proximity': 3.8129925999230694, 'min_proximity': 0.08903941047678145}\n"
     ]
    }
   ],
   "source": [
    "\n",
    "# Calcular distancias\n",
    "distancias_pto_pto = dataset.distancia_punto_punto(punto)\n",
    "print(\"\\nDistancias del punto a todos los puntos en el dataset:\")\n",
    "print(distancias_pto_pto)\n",
    "\n",
    "distancia_subconjunto = dataset.distancia_punto_subconjunto(punto, indices_subconjunto1)\n",
    "print(\"\\nDistancias del punto al subconjunto:\")\n",
    "print(distancia_subconjunto)\n",
    "\n",
    "proximidades = dataset.distancia_subconjunto_subconjunto(indices_subconjunto1, indices_subconjunto2)\n",
    "print(\"\\nMedidas de proximidad entre subconjuntos:\")\n",
    "print(proximidades)\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "base",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
